Let's start with the project!

import pandas as pd
import numpy as np
import pandas_datareader as web
import matplotlib.pyplot as plt

# Ask for the number of stocks the user wants to preselect
number = None
while number is None:
  try:
    number = int(input("Type the number of stocks you want to preselect: "))
  except ValueError:
    print ("You must type an integer, please try again.")

# date checking functions
def month_check(month):
    if month > 0 and month <= 12: ## If month is between 1 and 12, return True.
        return True
    else:
        return False

def day_check(month, day):
    days_in_month = {1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}
    if 0 < day <= days_in_month[month]:
        return True
    else:
        return False

def year_check(year):
    if len(year) >= 1 and len(year) <= 4: ## Check if year has between 1 to 4 numbers and return True.
        return True
    else:
        return False

earliest = str("1990-01-01")

def start_date_check(start_date):
  if startdate > earliest:
    return True
  else: 
    return False

today = str("2021-04-30")

def end_date_check(start_date):
  if enddate < today:
    return True
  else: 
    return False

def start_before_end(startdate, enddate):
  if startdate < enddate:
    return True
  else: 
    return False

# ask start date and check if correct
startdate = None
while startdate is None:
  try: 
    startdate = str(input("Enter the start date in YYYY-MM-DD format: ")) 
    year,month,day = startdate.split("-") 
    month_validity = month_check(int(month)) 
    day_validity = day_check(int(month),int(day)) 
    year_validity = year_check(year)
    start_validity = start_date_check(startdate)

    if month_validity and day_validity and year_validity and start_validity:
      print("The date {0} is valid.".format(startdate))

    else:
      print("The date {0} is invalid.".format(startdate))
      startdate = None
      
  except ValueError:
    print('Your input was not valid. Please enter the date in YYYY-MM-DD format.')  
    startdate = None
     

#Ask for end date
enddate = None
while enddate is None:
  try: 
    enddate = str(input("Enter the end date in YYYY-MM-DD format: ")) 
    year,month,day = enddate.split("-") 
    month_validity = month_check(int(month)) 
    day_validity = day_check(int(month),int(day)) 
    year_validity = year_check(year)
    end_validity = end_date_check(enddate)
    start_end_validity = start_before_end(startdate, enddate)

    if month_validity and day_validity and year_validity and end_validity and start_end_validity : 
      print("The date {0} is valid.".format(enddate))

    else:
      print("The date {0} is invalid.".format(enddate))
      enddate = None

  except ValueError:
    print('Your input was not valid. Please enter the date in YYYY-MM-DD format.')
    enddate = None
  
    
### end date part
##############################################

# Ask the user to input the tickers
tickers = []
i = 1
while i <= number: 
  try: 
    tick = str(input(f'Enter a {i}th Ticker: ')) 
    tick = tick.upper()
    tickers.append(tick)
    i += 1 
  except ValueError:
    print("Error - you have to enter a string. Try again.") 

# Print the ticker list
print("the ticker list is:", tickers )

# Ask the user to input the risk free rate
riskfree = None
while riskfree is None:
  try:
    riskfree = float(input("Enter the risk free rate in decimals: "))
  except ValueError:
    print ("You must type a float")


# Getting historical stock prices and volume from Yahoo Finance
price_historical = web.get_data_yahoo(tickers,
                           start = startdate,
                           end = enddate)['Adj Close']
                           
volume_data = web.get_data_yahoo(tick,
                           start = startdate,
                           end = enddate)['Volume']


# Remove stocks that were not available during this time period and remove the tickers that do not exist
price_historical = price_historical.dropna(axis=1, how='all')

# Computing the log returns
log_ret = np.log(price_historical/price_historical.shift(1))

###################################################################################

# We should add here a part where we get additional info from yahoo finance for each preselected stock and we compute for each stock some performance and risk metrics. Based on this additional information, the user then selects the final sample of stocks he wants to put in his portfolio and the rest of the code does the 3 types of portfolio optimization.

# Plotting the historical stock prices and volumes
price_data.plot(figsize=(20,10))
plt.xlabel('Date')
plt.ylabel('Closing Price')
plt.title('Adjusted Closing Price')

volume_data.plot(figsize=(20,10))
plt.xlabel('Date')
plt.ylabel('Volume')
plt.title('Volume Traded')


##################################################################################


# Computing the variance-covariance matrix
cov_mat = log_ret.cov() * 252 #252 trading days in a year
print(cov_mat)

# number of portfolio to simulate
n_portfolio = 7500

# Creating empty arrays to store portfolio weights, return, risk, and sharpe ratio 
all_weights = np.zeros((n_portfolio, len(price_historical.columns)))
port_returns = np.zeros((n_portfolio))
port_risk = np.zeros((n_portfolio))
sharpe_ratio = np.zeros((n_portfolio))

# Simulating the 7500 portfolios and storing their weights, returns, volatility, sharpe ratio
for i in range(n_portfolio):
  # Generating randon weigths using a uniform distribution
  weights = np.random.uniform(size = len(price_historical.columns))
  weights = weights/np.sum(weights)
  
  # Storing weights 
  all_weights[i,:] = weights
  
  # Storing return
  port_ret = np.sum(log_ret.mean() * weights)
  port_ret = (port_ret + 1) ** 252 - 1
  port_returns[i] = port_ret
  
  # Storing risk
  port_sd = np.sqrt(np.dot(weights.T, np.dot(cov_mat, weights)))
  port_risk[i] = port_sd
  
  # Storing Sharpe Ratio  
  sr = (port_ret - riskfree) / port_sd
  sharpe_ratio[i] = sr

names = price_historical.columns

# Finding the minimum variance portfolio
min_var = all_weights[port_risk.argmin()]
print("The weights of the minimum variance portfolio are:", min_var)

# Finding the tangency portfolio
max_sr = all_weights[sharpe_ratio.argmax()]
print("The weights of the maximum sharpe ratio portfolio are:", max_sr)

# Finding the equally weighted portfolio
eq_weights = []
for i in range(len(weights)):
 eq_weights.append(1/len(weights))
print("The weights of the equally weigthed portfolio are:", eq_weights)

# Finding the maximum return portfolio
max_ret = all_weights[port_ret.argmax()]
print("The weights of the maximum return portfolio are:", max_ret)


# Check if portfolio weights sum to 1
print(sum(min_var), sum(max_sr), sum(eq_weights), sum(max_ret))



################################################################################

# Here we can probably add some graphs and performance and risk metrics for each optimization so that the user can select the optimization he prefers

################################################################################
